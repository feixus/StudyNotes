#pragma once

// vulkan platform
#define VK_USE_PLATFORM_WIN32_KHR
//glfw
#define GLFW_EXPLOSE_NATIVE_WIN32
#define GLFW_INCLUDE_VULKAN
//glm
#define GL_ENABLE_EXPERIMENTAL
#define GLM_FORCE_RADIANS
//the perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default
//use the Vulkan range of 0.0 to 1.0 need this definition
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
// tiny obj
#define TINYOBJLOADER_IMPLEMENTATION

#include <GLFW/glfw3.h>
#include <GLFW/glfw3native.h>

#include <glm/glm.hpp>
#include <vulkan/vulkan.h>



#include <optional>
#include <vector>
#include <string>
#include <memory>

#include "Vertex.h"

const uint32_t WIDTH = 1024;
const uint32_t HEIGHT = 512;

const std::string MODEL_PATH = "models/viking_room.obj";
const std::string TEXTURE_PATH = "textures/viking_room.png";

//multiple frames to be in-flight at once. to fix waitting on the previous frame to finish before rendering the next. 
//so any resource that is accessed and modified during rendering must be duplicated. we need multiple command buffers, semephores, fences.
const int MAX_FRAMES_IN_FLIGHT = 2;

const std::vector<const char*> validationLayers = {
	"VK_LAYER_KHRONOS_validation"
};

const std::vector<const char*> deviceExtensions = {
	VK_KHR_SWAPCHAIN_EXTENSION_NAME
};

#ifdef NDEBUG
const  bool enableValidationLayers = false;
#else
const  bool enableValidationLayers = true;
#endif // NDEBUG

struct QueueFamilyIndices {
	std::optional<uint32_t> graphicsFamily; //for drawing commands
	std::optional<uint32_t> presentFamily; //for presentation
	std::optional<uint32_t> graphicsAndComputeFamily;
	bool isCompute;

	bool isComplete() {
		if (isCompute)
			return graphicsAndComputeFamily.has_value();

		return graphicsFamily.has_value() && presentFamily.has_value();
	}
};

struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR capabilities;
	std::vector<VkSurfaceFormatKHR> formats;
	std::vector<VkPresentModeKHR> presentModes;
};


class VulkanExampleBase
{
public:
    VulkanExampleBase();
    virtual ~VulkanExampleBase();

    virtual void initVulkan();
    virtual void recreateSwapChain();

	virtual void run();
	virtual void mainLoop();
	virtual void drawFrame() {};

	void createInstance();
	void setupDebugMessager();
	void createSurface();
	void pickPhysicalDevice();
	void createLogicDevice();
	void createSwapChain();
	void createImageViews();

	void createRenderPass();

	void createCommandPool();
	void createColorResources();
	void createDepthResources();
	void createFramebuffers();

	void createCommandBuffers();
	void createSyncObjects();

    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device, VkSurfaceKHR surface);
    
    static VkImageView createImageView(VkDevice device, VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, uint32_t mipLevels);
    static std::vector<char> readFile(const std::string& filename);
    static void OutputDetailInfos(VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, VkSurfaceKHR surface);
   
	static void loadModel(const std::string& path, std::vector<Vertex>& vertices, std::vector<uint32_t>& indices);

	void createBuffer(VkPhysicalDevice physicalDevice, VkDevice device, VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags propertices, VkBuffer& buffer, VkDeviceMemory& bufferMemory);
	void createImage(VkPhysicalDevice physicalDevice, VkDevice device, uint32_t width, uint32_t height, uint32_t mipLevels, VkSampleCountFlagBits numSamples, VkFormat format, VkImageTiling tilling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage& image, VkDeviceMemory& imageMemory);
	void transitionImageLayout(VkDevice device, VkQueue graphicQueue, VkCommandPool commandPool, VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, uint32_t mipLevels);
	void copyBufferToImage(VkDevice device, VkQueue graphicQueue, VkCommandPool commandPool, VkBuffer buffer, VkImage image, uint32_t width, uint32_t height);
	void generateMipmaps(VkPhysicalDevice physicalDevice, VkDevice device, VkQueue graphicQueue, VkCommandPool commandPool, VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels);
	void copyBuffer(VkDevice device, VkQueue queue, VkCommandPool commandPool, VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);
	VkShaderModule createShaderModule(VkDevice device, const std::vector<char>& code);
	bool isDeviceSuitable(VkPhysicalDevice device, VkSurfaceKHR surface);
	bool checkDeviceExtensionSupport(VkPhysicalDevice device);
	SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device, VkSurfaceKHR surface);

	virtual void cleanup();
	void cleanupSwapChain();

private:
	void initWindow();

protected:
    GLFWwindow* window;

	VkInstance instance;
    std::unique_ptr<class DebugMessager> debugMessager;
	VkPhysicalDevice physicalDevice{VK_NULL_HANDLE};
	VkDevice device;
	VkQueue graphicQueue;
	VkQueue presentQueue;

	VkSurfaceKHR surface;
	VkSwapchainKHR swapChain;
	std::vector<VkImage> swapChainImages;
	std::vector<VkImageView> swapChainImageViews;
	std::vector<VkFramebuffer> swapChainFrameBuffers;
	VkFormat swapChainImageFormat;
	VkExtent2D swapchainExtent;

    VkSampleCountFlagBits msaaSamples = VK_SAMPLE_COUNT_1_BIT;

	glm::mat4 modelMatrix = glm::mat4(1.0f);
	glm::vec3 viewDir = glm::vec3();
	glm::vec3 leftDir = glm::vec3();

	uint32_t currentFrame = 0;

	//an image has been acquired from the swapchain and is ready for rendering, rendering has finished and presentation can happen
	std::vector<VkSemaphore> imageAvailableSemaphores;
	std::vector<VkSemaphore> renderFinishedSemaphores;
	std::vector<VkFence> inFlightFences;

	VkRenderPass renderPass;
	VkDescriptorSetLayout descriptorSetLayout;
	VkPipelineLayout pipelineLayout;

	VkPipeline graphicsPipeline;

	VkCommandPool commandPool;
	std::vector<VkCommandBuffer> commandBuffers;

	uint32_t mipLevels;

	VkImage depthImage;
	VkDeviceMemory depthImageMemory;
	VkImageView depthImageView;

	VkImage colorImage;
	VkDeviceMemory colorImageMemory;
	VkImageView colorImageView;

public:
	float fov = 45.0f;
	bool framebufferResized = false;

};